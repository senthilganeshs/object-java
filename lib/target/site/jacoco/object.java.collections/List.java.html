<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>List.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lib</a> &gt; <a href="index.source.html" class="el_package">object.java.collections</a> &gt; <span class="el_source">List.java</span></div><h1>List.java</h1><pre class="source lang-java linenums">package object.java.collections;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;

public interface List&lt;T&gt; {

    void forEach (final Consumer&lt;T&gt; action);
    
    void forEach (final int start ,final int end, final Consumer&lt;T&gt; action) throws IndexOutOfBoundsException;
    
    void forIndex (final int index, final Consumer&lt;T&gt; action) throws IndexOutOfBoundsException;
    
    
    @SuppressWarnings(&quot;unchecked&quot;)
	static&lt;T&gt;  List&lt;T&gt; empty() {
<span class="fc" id="L22">        return (List&lt;T&gt;) EMPTY;</span>
    }
    
    @SafeVarargs
	static&lt;T&gt; List&lt;T&gt; of (final T...values) {
<span class="pc bpc" id="L27" title="1 of 4 branches missed.">    	if (values == null || values.length == 0)</span>
<span class="fc" id="L28">    		return empty();</span>
<span class="fc" id="L29">        return new NonEmpty&lt;&gt;(values);</span>
    }
    
    static &lt;T&gt; List&lt;T&gt; repeated (final int n, final T value) {
<span class="fc" id="L33">        return new Repeated&lt;&gt;(n, value);</span>
    }
    
    static&lt;T, R&gt; List&lt;R&gt; mapped (final Function&lt;T, R&gt; fn, final List&lt;T&gt; list) {
<span class="fc" id="L37">        return new Mapped&lt;&gt;(list, fn);</span>
    }
    
    static &lt;T, R&gt; List&lt;R&gt; flatMapped (final Function&lt;T, List&lt;R&gt;&gt; fn, final List&lt;T&gt; list) {
<span class="fc" id="L41">        return new FlatMapped&lt;&gt;(list, fn);</span>
    }
    
    @SafeVarargs
	static &lt;T&gt; List&lt;T&gt; linkedList (final T...values) {
<span class="fc" id="L46">        List&lt;T&gt; tail = empty();</span>
<span class="fc" id="L47">        List&lt;T&gt; list = tail;</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        for (T value : values) {</span>
<span class="fc" id="L49">            list = new TailList &lt;&gt;(list, value);</span>
        }
<span class="fc" id="L51">        return list;</span>
    }
    
    static&lt;T&gt; List&lt;T&gt; tailList (final List&lt;T&gt; head, final T tail) {
<span class="fc" id="L55">    	return new TailList&lt;&gt;(head, tail);</span>
    }
    
    
    static&lt;T&gt; List&lt;T&gt; par (final List&lt;T&gt; list, final ExecutorService es) {
<span class="fc" id="L60">    	return new Par&lt;&gt;(es, list);</span>
    }
    
    static&lt;T&gt; List&lt;T&gt; push (final T value, final List&lt;T&gt; stack) {
<span class="fc" id="L64">    	return new Cons&lt;&gt;(stack, value);</span>
    }
    
    static&lt;T&gt; List&lt;T&gt; pop (final List&lt;T&gt; stack) {
<span class="fc" id="L68">    	return new Popped&lt;&gt;(stack);</span>
    }
    
    static&lt;T&gt; List&lt;T&gt; enqueue (final List&lt;T&gt; queue, final T value) {
<span class="fc" id="L72">    	return new TailList&lt;&gt;(queue, value);</span>
    }
    
    static&lt;T&gt; List&lt;T&gt; dequeue (final List&lt;T&gt; queue) {
<span class="fc" id="L76">    	return new Dequeued&lt;&gt;(queue);</span>
    }
    
    final static class Dequeued&lt;T&gt; implements List&lt;T&gt; {

    	private final List&lt;T&gt; queue;

<span class="fc" id="L83">		Dequeued(final List&lt;T&gt; queue) {</span>
<span class="fc" id="L84">    		this.queue = queue;</span>
<span class="fc" id="L85">    	}</span>
    	
		@Override
		public void forEach(Consumer&lt;T&gt; action) {
			try {
<span class="fc" id="L90">				queue.forIndex(0, action);</span>
<span class="pc" id="L91">			} catch (IndexOutOfBoundsException e) {</span>
				//forEach should not throw exception;
			}
<span class="fc" id="L94">		}</span>

		@Override
		public void forEach(int start, int end, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="pc bpc" id="L98" title="1 of 4 branches missed.">			if (start == 0 &amp;&amp; end == 1) {</span>
<span class="fc" id="L99">				queue.forIndex(0, action);</span>
<span class="fc" id="L100">			} else {</span>
<span class="fc" id="L101">				throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
			}
<span class="fc" id="L103">		}</span>

		@Override
		public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L107" title="All 2 branches covered.">			if (index == 0) {</span>
<span class="fc" id="L108">				queue.forIndex(0, action);</span>
<span class="fc" id="L109">			} else {</span>
<span class="fc" id="L110">				throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
			}
<span class="fc" id="L112">		}</span>
    }
    
    final static class TailList&lt;T&gt; implements List&lt;T&gt; {

    	private final List&lt;T&gt; head;
		private final T tail;
		private final int headSize;

<span class="fc" id="L121">		TailList(final List&lt;T&gt; head, final T tail) {</span>
<span class="fc" id="L122">    		this.tail  = tail;</span>
<span class="fc" id="L123">    		this.head = head;</span>
<span class="fc" id="L124">    		this.headSize = sizeOf (head);</span>
<span class="fc" id="L125">    	}</span>
    	
		private int sizeOf(List&lt;T&gt; head2) {
<span class="fc" id="L128">			final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L129">			head2.forEach(t -&gt; counter.incrementAndGet());</span>
<span class="fc" id="L130">			return counter.get();</span>
		}

		@Override
		public void forEach(Consumer&lt;T&gt; action) {
<span class="fc" id="L135">			head.forEach(action);</span>
<span class="fc" id="L136">			action.accept(tail);</span>
<span class="fc" id="L137">		}</span>

		@Override
		public void forEach(int start, int end, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L141" title="All 4 branches covered.">			if (start == 0 &amp;&amp; end == 1) {</span>
<span class="fc" id="L142">				action.accept(tail); //special case singleton list.</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">			} else if (end &gt; headSize + 1) {</span>
<span class="fc" id="L144">				throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">			} else if (end == headSize + 1) {</span>
<span class="fc" id="L146">				head.forEach(start, end - 1, action);</span>
<span class="fc" id="L147">				action.accept(tail);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">			}else if (end == headSize) {</span>
<span class="fc" id="L149">				head.forEach(start, end, action);				</span>
<span class="fc" id="L150">			} else {</span>
<span class="fc" id="L151">				head.forEach(start, end, action);</span>
			}
<span class="fc" id="L153">		}</span>

		@Override
		public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L157" title="All 2 branches covered.">			if (index == headSize) {</span>
<span class="fc" id="L158">				action.accept(tail);</span>
<span class="fc" id="L159">			} else {</span>
<span class="fc" id="L160">				head.forIndex(index, action);</span>
			}
<span class="fc" id="L162">		}</span>
    }

    final static class Par&lt;T&gt; implements List&lt;T&gt; {

    	private final List&lt;T&gt; list;
		private final ExecutorService es;

<span class="fc" id="L170">		Par (final ExecutorService es, final List&lt;T&gt; list) {</span>
<span class="fc" id="L171">    		this.es = es;</span>
<span class="fc" id="L172">    		this.list = list;</span>
<span class="fc" id="L173">    	}</span>
    	
		@Override
		public void forEach(final Consumer&lt;T&gt; action) {
<span class="fc" id="L177">			final AtomicReference&lt;List&lt;Future&lt;?&gt;&gt;&gt; futures = new AtomicReference&lt;&gt;(List.empty());</span>
<span class="fc" id="L178">			list.forEach(t -&gt; {</span>
<span class="fc" id="L179">				futures.set(List.tailList(futures.get(), es.submit(() -&gt; action.accept(t))));</span>
<span class="fc" id="L180">			});</span>
			
<span class="fc" id="L182">			waitForResult(futures);</span>
<span class="fc" id="L183">		}</span>

		private void waitForResult(final AtomicReference&lt;List&lt;Future&lt;?&gt;&gt;&gt; futures) {
<span class="fc" id="L186">			futures.get().forEach(f -&gt; {</span>
				try {
<span class="fc" id="L188">					f.get();</span>
<span class="pc" id="L189">				} catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L190">					throw new RuntimeException(e);</span>
				}
<span class="fc" id="L192">			});</span>
<span class="fc" id="L193">		}</span>

		@Override
		public void forEach(int start, int end, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc" id="L197">			final AtomicReference&lt;List&lt;Future&lt;?&gt;&gt;&gt; futures = new AtomicReference&lt;&gt;(List.empty());</span>
<span class="fc" id="L198">			list.forEach(start, end, t -&gt; {</span>
<span class="fc" id="L199">				futures.set(List.tailList(futures.get(), es.submit(() -&gt; action.accept(t))));</span>
<span class="fc" id="L200">			});</span>
			
<span class="fc" id="L202">			waitForResult (futures);</span>
<span class="fc" id="L203">		}</span>

		@Override
		public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
			
<span class="fc" id="L208">			final AtomicReference&lt;Future&lt;?&gt;&gt; future = new AtomicReference&lt;&gt;();</span>
			
<span class="fc" id="L210">			list.forIndex(index, t -&gt; future.set(es.submit(() -&gt; action.accept(t))));</span>
			
<span class="fc" id="L212">			es.submit(() -&gt; future.get());</span>
<span class="fc" id="L213">		}</span>
    	
    }
    
<span class="fc" id="L217">    static List&lt;Void&gt; EMPTY = new Empty();</span>
    
    final static class Cons&lt;T&gt; implements List&lt;T&gt; {
        private final T one;
        private final List&lt;T&gt; list;
        private final int endIndex;

<span class="fc" id="L224">        Cons(final List&lt;T&gt; list, final T one) {</span>
<span class="fc" id="L225">            this.list = list;</span>
<span class="fc" id="L226">            this.one = one;        </span>
<span class="fc" id="L227">            endIndex = sizeOf (list) - 1;</span>
<span class="fc" id="L228">        }</span>

        private int sizeOf(List&lt;T&gt; list2) {
<span class="fc" id="L231">			final AtomicInteger counter = new AtomicInteger(0);</span>
<span class="fc" id="L232">			list2.forEach(t -&gt; counter.incrementAndGet());</span>
<span class="fc" id="L233">			return counter.get();</span>
		}

		@Override
        public void forEach(Consumer&lt;T&gt; action) {
<span class="fc" id="L238">            action.accept(one);</span>
<span class="fc" id="L239">            list.forEach(action);            </span>
<span class="fc" id="L240">        }</span>

        @Override
        public void forEach(int start, int end, Consumer&lt;T&gt; action)
            throws IndexOutOfBoundsException {
<span class="pc bpc" id="L245" title="5 of 6 branches missed.">        	if (endIndex == -1 &amp;&amp; end == 1 &amp;&amp; start == 0) { //empty tail </span>
<span class="nc" id="L246">        		action.accept(one);</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        	} else if (end &gt; endIndex + 2) { //end index greater than tial + j</span>
<span class="nc" id="L248">        		throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        	} else if (end &lt;= endIndex + 2) { //end index equal to last value of tail list.</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        		if (start == 0) {</span>
<span class="fc" id="L251">                 	action.accept(one);</span>
<span class="fc" id="L252">                 	list.forEach(start, end - 1, action);</span>
<span class="fc" id="L253">                 } else {</span>
<span class="nc" id="L254">                	 list.forEach(start - 1, end - 1, action);</span>
                 }
            }
<span class="fc" id="L257">        }</span>

        @Override
        public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (index == 0)</span>
<span class="fc" id="L262">                action.accept(one);</span>
            else {
<span class="fc" id="L264">                list.forIndex (index - 1, action);</span>
            }
<span class="fc" id="L266">        }</span>
    }
    
    final static class Mapped&lt;T, R&gt; implements List&lt;R&gt; {

        private final Function&lt;T, R&gt; fn;
        private final List&lt;T&gt; list;

<span class="fc" id="L274">        Mapped (final List&lt;T&gt; list, final Function&lt;T, R&gt; fn) {</span>
<span class="fc" id="L275">            this.list = list;</span>
<span class="fc" id="L276">            this.fn = fn;</span>
<span class="fc" id="L277">        }</span>
        
        @Override
        public void forEach(Consumer&lt;R&gt; action) {
<span class="fc" id="L281">            list.forEach(t -&gt; action.accept(fn.apply(t)));</span>
<span class="fc" id="L282">        }</span>

        @Override
        public void forEach(int start, int end, Consumer&lt;R&gt; action)
            throws IndexOutOfBoundsException {
<span class="fc" id="L287">            list.forEach(start, end, t -&gt; action.accept(fn.apply(t)));</span>
<span class="fc" id="L288">        }</span>

        @Override
        public void forIndex(int index, Consumer&lt;R&gt; action) throws IndexOutOfBoundsException {
<span class="fc" id="L292">            list.forIndex (index, t -&gt; action.accept(fn.apply(t)));</span>
<span class="fc" id="L293">        }           </span>
    }
    
    final static class Repeated&lt;T&gt; implements List&lt;T&gt; {

        private final List&lt;T&gt; list;

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L301">		Repeated (final int n, final T value) {</span>
<span class="fc" id="L302">            java.lang.Object values[] = new java.lang.Object[n];</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            for (int i = 0; i &lt; values.length; i ++) {</span>
<span class="fc" id="L304">                values[i] = value;</span>
            }
<span class="fc" id="L306">            this.list = (List&lt;T&gt;) List.of(values);</span>
<span class="fc" id="L307">        }</span>
        
        @Override
        public void forEach(Consumer&lt;T&gt; action) {
<span class="fc" id="L311">            list.forEach(action);</span>
<span class="fc" id="L312">        }</span>

        @Override
        public void forEach(int start, int end, Consumer&lt;T&gt; action)
            throws IndexOutOfBoundsException {
<span class="fc" id="L317">            list.forEach(start, end, action);</span>
<span class="fc" id="L318">        }</span>

        @Override
        public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc" id="L322">            list.forIndex(index, action);</span>
<span class="fc" id="L323">        }</span>
        
    }
    
    final static class FlatMapped&lt;T, R&gt; implements List&lt;R&gt; {
        private final List&lt;R&gt; list;
       
<span class="fc" id="L330">        FlatMapped (final List&lt;T&gt; list, final Function&lt;T, List&lt;R&gt;&gt; fn) {</span>
<span class="fc" id="L331">        	final AtomicReference&lt;List&lt;R&gt;&gt; l = new AtomicReference&lt;&gt;(List.empty());</span>
<span class="fc" id="L332">            list.forEach(t -&gt; fn.apply(t).forEach(t1 -&gt; {</span>
<span class="fc" id="L333">                l.set(List.tailList(l.get(), t1));</span>
<span class="fc" id="L334">            }));</span>
            
<span class="fc" id="L336">            this.list = l.get();</span>
<span class="fc" id="L337">        }</span>

        @Override
        public void forEach(final Consumer&lt;R&gt; action) {
<span class="fc" id="L341">            list.forEach(action);</span>
<span class="fc" id="L342">        }</span>

        @Override
        public void forEach(int start, int end, Consumer&lt;R&gt; action)
            throws IndexOutOfBoundsException {
<span class="fc" id="L347">            list.forEach(start, end, action);</span>
<span class="fc" id="L348">        }</span>

        @Override
        public void forIndex(int index, Consumer&lt;R&gt; action) throws IndexOutOfBoundsException {
<span class="fc" id="L352">            list.forIndex(index, action);</span>
<span class="fc" id="L353">        }            </span>
    }
    
    final static class Popped&lt;T&gt; implements List&lt;T&gt; {

    	private final List&lt;T&gt; list;
		private final int lastIndex;

<span class="fc" id="L361">		Popped (final List&lt;T&gt; stack) {</span>
<span class="fc" id="L362">    		this.list = stack;</span>
<span class="fc" id="L363">    		this.lastIndex = sizeOf(list) - 1;</span>
<span class="fc" id="L364">    	}</span>
    	
		private int sizeOf(List&lt;T&gt; list2) {
<span class="fc" id="L367">			final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L368">			list2.forEach(t -&gt; counter.incrementAndGet());</span>
<span class="fc" id="L369">			return counter.get();</span>
		}

		@Override
		public void forEach(Consumer&lt;T&gt; action) {
<span class="fc" id="L374">			list.forIndex(lastIndex, action);</span>
<span class="fc" id="L375">		}</span>

		@Override
		public void forEach(int start, int end, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="pc bpc" id="L379" title="1 of 4 branches missed.">			if (start == 0 &amp;&amp; end == 1) {</span>
<span class="fc" id="L380">				list.forIndex(lastIndex, action);</span>
<span class="fc" id="L381">			} else {</span>
<span class="fc" id="L382">				throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
			}
<span class="fc" id="L384">		}</span>

		@Override
		public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc bfc" id="L388" title="All 2 branches covered.">			if (index == 0) {</span>
<span class="fc" id="L389">				list.forIndex(lastIndex, action);</span>
<span class="fc" id="L390">			} else {</span>
<span class="fc" id="L391">				throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
			}
<span class="fc" id="L393">		}</span>
    }
    
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">    final static class NonEmpty&lt;T&gt; implements List&lt;T&gt; {</span>
        
        private final T[] values;

        @SafeVarargs
<span class="fc" id="L401">		NonEmpty(final T...values) {</span>
<span class="fc" id="L402">            this.values = values;</span>
<span class="pc bpc" id="L403" title="3 of 6 branches missed.">            assert (this.values != null &amp;&amp; values.length != 0);</span>
<span class="fc" id="L404">        }</span>

        @Override
        public void forEach(final Consumer&lt;T&gt; action) {
<span class="fc bfc" id="L408" title="All 2 branches covered.">            for (final T value  :values) {</span>
<span class="fc" id="L409">                action.accept(value);</span>
            }
<span class="fc" id="L411">        }</span>

        @Override
        public void forEach(int start, int end, Consumer&lt;T&gt; action)
            throws IndexOutOfBoundsException {
            
<span class="pc bpc" id="L417" title="2 of 4 branches missed.">            if ((start &lt; 0 || start &gt;= values.length) ||</span>
<span class="pc bpc" id="L418" title="2 of 4 branches missed.">                (end &lt;= 0   || end &gt; values.length) ||</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">                (start &gt;= end)) {</span>
<span class="nc" id="L420">                throw new IndexOutOfBoundsException(&quot;index out of range.&quot;);</span>
            }
            
<span class="fc bfc" id="L423" title="All 2 branches covered.">            for (int i = start; i &lt; end; i ++) {</span>
<span class="fc" id="L424">                action.accept(values[i]);</span>
            }
<span class="fc" id="L426">        }</span>

        @Override
        public void forIndex(int index, Consumer&lt;T&gt; action) throws IndexOutOfBoundsException {
<span class="fc" id="L430">            action.accept(values[index]);</span>
<span class="fc" id="L431">        }            </span>
    }
    
    
    final static class Empty implements  List&lt;Void&gt; {

<span class="fc" id="L437">        Empty() {}</span>
        
        @Override
        public void forEach(Consumer&lt;Void&gt; action) {
            // TODO Auto-generated method stub
            
<span class="fc" id="L443">        }</span>

        @Override
        public void forEach(int start, int end, Consumer&lt;Void&gt; action)
            throws IndexOutOfBoundsException {
<span class="nc" id="L448">            throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
        }

        @Override
        public void forIndex(int index, Consumer&lt;Void&gt; action)
            throws IndexOutOfBoundsException {
<span class="nc" id="L454">            throw new IndexOutOfBoundsException(&quot;index out of range&quot;);</span>
        }
    }   
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>